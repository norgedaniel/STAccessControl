------------------------------------------------------------------------
Building forms with Tag Helpers.

	- Building forms easily with Tag Helpers
	- Generating URLs with the Anchor Tag Helper
	- Using Tag Helpers to add functionality to Razor

Tag Helpers are new to ASP.NET Core. They can be used to customize the HTML generated in our templates.
They can be added to an otherwise standard HTML element, such as an <input>, to customize its attributes based on our C# model.
Tag Helpers can also be standalone elements and can be used to generate completely customized HTML.

They simplify the process of generating correct element names and IDs so that model binding can occur seamlessly when the form is sent back to our application.

Beside of use Tag Helpers to work with forms, we’ll also see how we can use Tag Helpers to simplify other common tasks, such as generating links, 
conditionally displaying data in our application, and ensuring users see the latest version of an image file when they refresh their browser.

Related to forms, we can use Tag Helpers to generate labels, drop-downs, input elements, validation messages.

Tag Helpers integrate seamlessly into the standard HTML syntax by adding what look to be attributes, typically starting with asp-*.

Tag Helpers blend in so well with the HTML! This makes it easy to edit the files with any standard HTML text editor.

Example of using of Tag Helpers to help in the generation of form:

	<div class="form-group">
		<label asp-for="CurrencyFrom"></label>
		<input class="form-control" asp-for="CurrencyFrom" />
		<span asp-validation-for="CurrencyFrom"></span>
	</div>

Here we have created a label, input and validation for an specific property in our view model
asp-for on Inputs generates the correct type, value, name, and validation attributes for the model.

IMPORTANT: Usually the HTML tag <span> is used to show some validation message.

Tag Helpers are extra attributes on standard HTML elements (or new elements entirely) that work by modifying the HTML element they’re attached to. 
They let us easily integrate our server-side values, such as those exposed on our PageModel, with the generated HTML.

Tag Helpers are used to:

	- Automatically populate the value from the PageModel property.
	- Choose the correct id and name, so that when the form is POSTed back to the Razor Page, the property will be model-bound correctly.
	- Choose the correct input type to display (for example, a number input for the Quantity property).
	- Display any validation errors.

Tag Helpers can make multiple attributes available on an element. These attributes are properties on a Tag Helper configuration object.
Adding a single asp- attribute activates the Tag Helper on the element. 
Adding additional attributes lets us override further default values of its implementation.


--------------------------------------------------------------------------------
Tag helpers in forms:

The first tag helper is to determine the URL the form will be posted to.
<form asp-page="Checkout">   in this case we are telling the Checkout page will process the form.

The Label Tag Helper uses DataAnnotations on a property to determine the caption to display.
<label asp-for="Input.FirstName"></label>

The Input Tag Helper uses DataAnnotations to determine the type of input to generate.
<input asp-for="Input.Email" />

The Validation Tag Helper displays error messages associated with the given property.
<span asp-validation-for="Input.PhoneNumber"></span>


IMPORTANT:
 - With Razor Pages, we often expose the same object in our view that we use for model binding. When we do this, 
   we must be careful to not include sensitive values (that shouldn’t be edited) in the binding model, 
   to avoid mass-assignment attacks on our app.

 - With the help of the UserBindingModel property, Tag Helpers, and a little HTML, we can create a Razor view that lets the user enter their details.

 - If we need the final generated HTML to have a particular attribute, we can add it to our markup. For example adding the class atribute for CSS style.
   We ca also override explicitally some atribute generated by the tag helper. 
   Example: if the FavoriteColor property on our PageModel was a string, then by default Tag Helpers would generate an <input> element with type="text". 
   Updating our markup to use the HTML5 color picker type is trivial; set the type explicitly in our Razor view:   <input type="color" asp-for="FavoriteColor" />

 - Tag helpers don´t override attributes of some HTML tag that we set our self.



-----------------------------------------------------------------------------
The Form Tag Helper.

The first tag helper to the Form HTML tag is asp-page, which is translated to the action and method attributes into the HTML. Example:
  <form asp-page="Checkout">    -->   <form action="/Checkout" method="post">

If we omit the asp-page attribute, we must set the method="post" attribute in order to be sure the form will be send as POST and not as GET.
In this case, the form will be submited to the same URL where it was served from. This is, the page where the form is.
The best practice is to define the asp-page attribute in order to avoid forget the method="post" attribute.

IMPORTANT: The Form Tag Helper makes several other attributes available on the <form> element that we can use to customize the generated URL.
           Example of this is the attribute asp-route-* . See the use of a wildcard.
		   Whis this attribute we can set the parameters needed by the route template defined into some razor page.
		   Example: if we have a route template like @page "{id}"  into the page Product.cshtml, this defines the page is pending to receive some value for
		   the parameter id. Then we can define a form like this:

		   <form asp-page="Product" asp-route-id="5">   See the wildcard has been replaced by the name of parameter id, specified in the page route template.

		   This code will generate the HTML:   <form action="/Product/5" method="post">

		   The value for the id parameter could be dynamic:  <form asp-page="Product" asp-route-id="@Model.ProductId"> 

		   We can add as many asp-route-* attributes as necessary to our <form> to generate the correct action URL. 
		   We can also set the Razor Page handler to use the asppage-handler attribute.

Some most used attributes for Form tag helper:

- asp-page: to specify the razor where the form will do summit. We can not specify this value to select the same page where the form is.

- asp-route-*: to specify some element of the route template of the page to do summit.

- asp-action: to specify the action controller to do summit into a MVC project.

- asp-controller: to specify the specific controller inside the action controller file to do summit into a MVC project.

- asp-route: to specify a named route (not used with Razor Pages). Search in deep if necessary.

The main job of the Form Tag Helper is to generate the action attribute, but it performs one additional, important function: 
generating a hidden <input> field needed to prevent cross-site request forgery (CSRF) attacks. 
Cross-site request forgery (CSRF) attacks are a website exploit that can allow actions to be executed on our website by an unrelated malicious website.


------------------------------------------------
The Label Tag Helper.

The Label Tag Helper is used to generate the caption (the visible text) and the for attribute for a <label> element, based on the properties in the PageModel. 
It’s used by providing the name of the property in the asp-for attribute:  
     <label asp-for="FirstName"></label>

The Label Tag Helper uses the [Display] DataAnnotations attribute that to determine the appropriate value to display.

If the property we’re generating a label for doesn’t have a [Display] attribute, the Label Tag Helper will use the name of the property instead.
Example of [Display] attribute:

	[Display(Name = "First Name:")]
	public string FirstName { get; set; }   will generate:  <label for="FirstName">First Name:</label>

As well as properties on the PageModel, we can also reference sub-properties on child objects:
	<label asp-for="Input.FirstName"></label>
	<label asp-for="Input.Email"></label>


-----------------------------------------------------
The Input and Textarea Tag Helpers.

the Input Tag Helper is one of the most powerful Tag Helpers. 
It uses information based on both the type of the property (bool, string, int, and so on) and any DataAnnotations attributes applied to it 
([EmailAddress] and [Phone], among others) to determine the type of the input element to generate.
The DataAnnotations are also used to add data-val-* client-side validation attributes to the generated HTML.

Example: if we have a bond property with a [EmailAddress] data annotation, the tag helper: <input asp-for="Input.Email" />   will generate:

	<input   type="email"   id="Input_Email"   name="Input.Email"  	value="test@example.com" 
	  data-val="true"  	data-val-email="The Email Address field is not a valid e-mail address."    
	  Data-val-required="The Email Address field is required."
	/>

See the generated attributes:
	type="email"				--> this is because the use of  [EmailAddress] data annotation.
	id="Input_Email"			--> the name of the bond property is used for the input id attribute.
	name="Input.Email"			--> the name of the bond property is used for the input name attribute. 
	                                See it matches completly with the property name, including the dot. What it makes possible the Binding process when submit is done.
	value="test@example.com"	--> initial value of the field has been set to the value currently stored in the property.
	data-val="true"  	
	data-val-email="The Email Address field is not a valid e-mail address."    
	Data-val-required="The Email Address field is required."

data-val-* attributes are related to validations to be ejecuted by client-side JavaScript libraries such as jQuery 
to provide client-side validation of our DataAnnotations constraints. 

In order to enable client-side validation in our application, we need to add some jQuery libraries to our HTML pages. 
In particular, we need to include the following JavaScript libraries:
	- jQuery
	- jQuery-validation
	- jQuery-validation-unobtrusive 

If we are using the default razor template we can include these libraries into our razor views by addinf the code below in some place of the view, 
usually at the end of the view:

	@section Scripts{
		@Html.Partial("_ValidationScriptsPartial")
	}

_ValidationScriptsPartial partial view contains the <script> sentences to include the libraries. The javascript files referenced are in our wwwroot folder.
The default _layout template includes jQuery itself, as that’s required by the front-end component library Bootstrap.

The Input Tag Helper tries to pick the most appropriate template for a given property based on DataAnnotations attributes or the type of the property.
As always, we can override the generated type by adding our own type attribute to the element in our Razor template.

NOTE: See Table 8.1 Common data types, how to specify them, and the input element type they map to.   Page 239.

Tag helper can use the attribute asp-format to set some specific format for the values to display over the HTML element generated. 
By default the elements are rendered using the standard format with the C# string.Format() method.
The use of asp-format can be translated into for example:
		<input asp-for="Dec" asp-format="{0:0.000}" />       -->  <input type="text" id="Dec" name="Dec" value="1.200">

There is a similar tag helper for HTML text area tag:   <textarea asp-for="BigtextValue"></textarea>    translated into:

	<textarea    data-val="true"    id="BigtextValue"    name="BigtextValue"
	     data-val-length="Maximum length 200."     data-val-length-max="200"
	     data-val-required="The Multiline field is required." >
	   This is some text, I'm going to display it in a text area
	</textarea>


IMPORTANT: At the end, tag helpers do facilitate us the way we can introduce HTML tags into our razor pages, connected with our bussines model 
and minimizing the need to introduce C# code into our views. But, better: tag helpers ensure that the markup generated is correct, 
and has the correct name, id, and format to automatically bind our binding models when they’re sent to the server.


-------------------------------------------------------------------
The Select Tag Helper.

To use <select> elements in our Razor code, we’ll need to include two properties in our PageModel: 
one property for the list of options to display, and one to hold the value (or values) selected.

The most used list of options to display is an implementation of IEnumerable<SelectListItem>:  Example:

public class SelectListsModel: PageModel
{

	[BindProperty]
	public class InputModel Input { get; set; }      // the variable to hold the user´s selection could be inside our bond Input object

	public IEnumerable<SelectListItem> Items { get; set; } 	= new List<SelectListItem>
	{
		new SelectListItem{Value= "csharp", Text="C#"},
		new SelectListItem{Value= "python", Text= "Python"},
		new SelectListItem{Value= "cpp", Text="C++"},
		new SelectListItem{Value= "java", Text="Java"},
		new SelectListItem{Value= "js", Text="JavaScript"},
		new SelectListItem{Value= "ruby", Text="Ruby"},
	};

	// class for binding model.
	public class InputModel
	{
		public string SelectedValue1 { get; set; }				// variable to hold the user´s selection on a drop down list.

		public IEnumerable<string> MultiValues { get; set; }	// variable to hold the user´s selection on a multiselect list box.

	}

}

NOTE: See how the SelectListItem class has two properties: one to hold the value to select itself and one for the value to be shown into the list or drop down list.
	  The Select Tag Helper only works with SelectListItem elements. 
	  That means we’ll normally have to convert from an application-specific list set of items (for example, a List<string> or List<MyClass>) 
	  to the UI-centric List<SelectListItem>.

Another way to fill a select tag helper is from some enum list. Search this in Internet.

IMPORTANT: We can define some string for each enum value to be used as text to show instead of the value itself. This is throught the data annotation: [StringValue("")]
Example:

        public enum TipoAreaAccesoOrderByOptions
        {
            [StringValue("Reciente")]
            DefaultOrder,

            [StringValue("Nombre ASC")]
            NombreAsc,

            [StringValue("Nombre DESC")]
            NombreDesc

        }

Then we can program an extension method to the enum class to get access to this StringValue().  See our class STCA_Tool.StringValueAttribute in our project.

To specify this StringValue as text for our list we do:

        public IEnumerable<SelectListItem> OrdenDatosItems { get; set; }
            = new List<SelectListItem>
            {
                new SelectListItem{Value= TipoAreaAccesoExtension.TipoAreaAccesoOrderByOptions.DefaultOrder.ToString(),
                                   Text=TipoAreaAccesoExtension.TipoAreaAccesoOrderByOptions.DefaultOrder.GetStringValue()},

                new SelectListItem{Value= TipoAreaAccesoExtension.TipoAreaAccesoOrderByOptions.NombreAsc.ToString(),
                                   Text=TipoAreaAccesoExtension.TipoAreaAccesoOrderByOptions.NombreAsc.GetStringValue()},

                new SelectListItem{Value= TipoAreaAccesoExtension.TipoAreaAccesoOrderByOptions.NombreDesc.ToString(),
                                   Text=TipoAreaAccesoExtension.TipoAreaAccesoOrderByOptions.NombreDesc.GetStringValue()}

            };  // see the call to GetStringValue() method.

The Select Tag Helper exposes the asp-for and asp-items attributes that we can add to <select> elements. 
As for the Input Tag Helper, the asp-for attribute specifies the property in our PageModel to bind to. 
The asp-items attribute is provided for the IEnumerable<SelectListItem> to display the available <option> elements.

It’s common to want to display a list of enum options in a <select> list.
This is so common that ASP.NET Core ships with a helper for generating a SelectListItem for any enum. 
If we have an enum of the TEnum type, we can generate the available options in our view using asp-items="Html.GetEnumSelectList<TEnum>()"

We define a drop down list in our view as this way:

            <select asp-for="Input.OrdenDatos" asp-items="Model.OrdenDatosItems"></select>

IMPORTANT: See how the asp-for does not include reference to the Model, instead it refers to the Input variable; our binding variable.
           In other hands, asp-items does refer to a property in our Model; but could refers values in other sources: ViewData dictionary.... 

If we want to include an option to the user for "** no selection ** " as  first choice of a select, we can create a SelectListItems for this in out list of choices,
or specify it as HTML tag. Example:

	<select asp-for="SelectedValue" asp-items="Model.Items">
		<option Value = "">**Not selected**</option>
	</select>


-----------------------------------------------------------------------------
The Validation Message and Validation Summary Tag Helpers.

Input Tag Helper generates the necessary data-val-* validation attributes on form input elements themselves.

This can be achieved for each property in our view model using the Validation Message Tag Helper applied to a <span> by using the asp-validation-for attribute:
	<span asp-validation-for="Email"></span>

When an error occurs during client-side validation, the appropriate error message for the referenced property will be displayed in the <span>.
This <span> element will also be used to show appropriate validation messages if serverside validation fails and the form is being redisplayed.

We can also display a summary of all the validation messages in a <div> by using the Validation Summary Tag Helper.
This renders a <ul> containing a list of the ModelState errors.

The Validation Summary Tag Helper is applied to a <div> using the asp-validationsummary attribute and providing a ValidationSummary enum value:
	"None"			Don’t display a summary.
	"ModelOnly"		Only display errors that are not associated with a property.
	"All"			Display errors either associated with a property or with the model.

The Validation Summary Tag Helper is particularly useful if we have errors associated with our page that aren’t specific to a single property.
These can be added to the model state by using a blank key. Example:

	public IActionResult OnPost()
	{
		// if the user request to convert into the same currency, we introduce an error with empty key to the model.
		if(Input.CurrencyFrom == Input.CurrencyTo)
			ModelState.AddModelError(string.Empty, "Cannot convert currency to itself");

		// If there are any propertylevel or model-level errors, display them.
		if (!ModelState.IsValid)
			return Page();
		
		//store the valid values somewhere etc
		return RedirectToPage("Checkout");

	}

For simplicity, in this example the the validation check has been added to the page handler. 
A better approach might be to create a custom validation attribute to achieve this instead. 
That way, our handler stays lean and sticks to the single responsibility principle.


-------------------------------------------------------------------------
Generating links with the Anchor Tag Helper.

We can use the Anchor Tag Helper to generate the URL for a given Razor Page using routing.
We provide asp-page and asp-page-handler attributes, along with asp-route-* attributes as necessary. Examples:

	<a asp-area="" asp-page="/Index">Home</a>			translated into:	<a href="/">Home</a> 

	<a asp-area="" asp-page="/Privacy">Privacy</a>		translated into:	<a href="/Privacy">Privacy</a>

There are other asp- properties we can set in order to get more control over the URL we want to point. Here the most used for Razor pages:

- asp-page:			Sets the Razor Page to execute.

- asp-page-handler: Sets the Razor Page handler to execute.

- asp-area:			Sets the area route parameter to use. Areas can be used to provide an additional layer of organization to our application.

- asp-host:			If set, the link will point to the provided host and will generate an absolute URL instead of a relative URL.

- asp-protocol:		Sets whether to generate an http or https link. If set, it will generate an absolute URL instead of a relative URL.

- asp-route-*:		Sets the route parameters to use during generation. Can be added multiple times for different route parameters



-----------------------------------------------------------------------------
Button Tag Helper.

The HTML tag <button> also support tag helpers, most related with how the submit action should be done. 
We can have a form with several buttons. The form has a default submit processing where we can specify all the data needed for routing.
But each one of these buttons could have different kind of submit processing, different parameters for routing.
Think a page showing a list of records where we need to put some buttons for paging: First Page, Previous Pagew, Next Page, Final Page.

The allowed tag helpers are the same of Anchor Tag Helper. Most of the time we need to specify just a diferent parameters for routing, as the page number to display.
In this case we just need to specify those parameters throught the asp-route-* tag helper, assuming that the handler method will be the same of the form. 
Example of buttons for paging:

    <button asp-route-pagenumber="1">Primera página</button>&nbsp;&nbsp;
    <button asp-route-pagenumber="@(Model.pagenumber-1)">Anterior</button>&nbsp;&nbsp;
    <button asp-route-pagenumber="@(Model.pagenumber+1)">Siguiente</button>&nbsp;&nbsp;
    <button asp-route-pagenumber="@Model.TiposAreasAccesoList.PagesCount">Ultima página</button>

In this case the parameter is pagenumber and we should add it into our routing page directive at the begining of our page razor view template, the .chhtml file:
	@page  "{pagenumber:int=1}"

Here we are adding pagenumber to our routing template as an optional int with 1 as default value.

There could be the time where we need a different handler to process the button submit request. For this case we can use the asp-page-handler tag helper.
Here we should specify the name of handler method excluing the name of the kind of submit method: GET or POST.

Example: 

            <button asp-page-handler="Pagina" asp-route-pagenumber="1">Primera página</button>

Here we specify the handler method as "Pagina" for POST, the default kind of submit of the form. Then we need to program this method as this way:

        public void OnPostPagina(int pagenumber)
        {
            RefreshData(pagenumber);
        }

Here specify the submit method "OnPost" + the name of the handler method "Pagina". We specify also the parameter sent by the button.

IMPORTANT: These are two ways of implement several buttons for a same form. We should try other combination of using tag helpers with buttons.

			https://www.learnrazorpages.com   AN IMPORTANT SITE TO GO DEEP WITH RAZOR PAGES.


----------------------------------------------------------------------------
Cache-busting with the Append Version Tag Helper.

A common problem with web development is ensuring that browsers are all using the latest files. This is because for performance reasons, 
browsers often cache files locally and reuse them for subsequent requests, rather than calling our application every time a file is requested.
For example, if some javascript file has changed and the user browser keep using a cached file, the App could be broken for this user.

In this case the browser should be always get the new files instead to work with cached files. 
To solve this kind of issue, there is the "cache-busting query string", a technique to add a query parameter to the URL of the related static file.
This file could be an imagen, some script, any static file. Example:
	
	<script src="~/js/site.js?version=1"></script>  

see the string "version=1" at the end of the URL. If the file is updated, this string should be changed in order to forze the browser to get the new file.

There is a Tag Helper to rebuild this string everytime the file is updated. It generates a unique hash based on the content of the file. 
So, everytime que file is updated, a new hash is generated. Of course, this hash is used as this "cache-busting query string".
The tag helper is: asp-append-version="true". Example:

	<script src="~/js/site.js" asp-append-version="true"></script>     translated into:   
	
	<script src="/js/site.js?v=EWaMeWsJBYWmL2g_KkgXZQ5nPe"></script>


-----------------------------------------------------------------------------
Using conditional markup with the Environment Tag Helper.

In many cases, we want to render different HTML in our Razor templates depending on whether our website is running in a development or production environment.
For example, in development we typically want our JavaScript and CSS assets to be verbose and easy to read, but in production we’d process these files 
to make them as small as possible. Another example might be the desire to apply a banner to the application when it’s running in a testing environment, 
which is removed when we move to production.

We could resolve this by inserting some c# if:

	@if(env == "Testing" || env == "Staging")
	{
		<div class="warning">This is the testing environment</div>
	}

or using the EnvironmentTagHelper tag helper:

	<environment include="Testing,Staging">
		<div class="warning">This is the testing environment</div>
	</environment>

See how this tag helper is a little different from the others we’ve seen before. Instead of augmenting an existing HTML element using an asp- attribute, 
the whole element is the Tag Helper. IMPORTANT: Just is pending to know how to set the env variable.


-----------------------------------------------------------------
Summary:

- With Tag Helpers, we can bind our data model to HTML elements, making it easier to generate dynamic HTML while remaining editor friendly.

- As with Razor in general, Tag Helpers are for server-side rendering of HTML only. We can’t use them directly in frontend frameworks, such as Angular or React.

- Tag Helpers can be standalone elements or can attach to existing HTML using attributes. This lets us both customize HTML elements and add entirely new elements.

- Tag Helpers can customize the elements they’re attached to, add additional attributes, and customize how they’re rendered to HTML. 
  This can greatly reduce the amount of markup we need to write.

- Tag Helpers can expose multiple attributes on a single element. This makes it easier to configure the Tag Helper, as we can set multiple, separate values.

- We can add the asp-page and asp-page-handler attributes to the <form> element to set the action URL using the URL generation feature of Razor Pages.

- We specify route values to use during routing with the Form Tag Helper using asp-route-* attributes. 
  These values are used to build the final URL or are passed as query data.

- The Form Tag Helper also generates a hidden field that we can use to prevent CSRF attacks. This is added automatically and is an important security measure.

- We can attach the Label Tag Helper to a <label> using asp-for. 
  It generates an appropriate for attribute and caption based on the [Display] Data-Annotations attribute and the PageModel property name.

- The Input Tag Helper sets the type attribute of an <input> element to the appropriate value based on a bound property’s Type and any DataAnnotations applied to it. 
  It also generates the data-val-* attributes required for clientside validation. This significantly reduces the amount of HTML code we need to write.

- To enable client-side validation, we must add the necessary JavaScript files to our view for jQuery validation and unobtrusive validation.

- The Select Tag Helper can generate drop-down <select> elements as well as list boxes, using the asp-for and asp-items attributes. 
  To generate a multiselect <select> element, bind the element to an IEnumerable property on the view model. 
  We can use these approaches to generate several different styles of select box.

- The items supplied in asp-for must be an IEnumerable<SelectListItem>. If we try to bind another type, we’ll get a compile-time error in our Razor view.

- We can generate an IEnumerable<SelectListItem> for an enum TEnum using the Html.GetEnumSelectList<TEnum>() helper method. 
  This saves us having to write the mapping code ourself.

- The Select Tag Helper will generate <optgroup> elements if the items supplied in asp-for have an associated SelectListGroup on the Group property. 
  Groups can be used to separate items in select lists.

- Any extra additional <option> elements added to the Razor markup will be passed through to the final HTML. 
  We can use these additional elements to easily add a “no selection” option to the <select> element.

- The Validation Message Tag Helper is used to render the client- and server-side validation error messages for a given property. 
  This gives important feedback to our users when elements have errors. Use the asp-validation-for attribute to attach the Validation Message Tag Helper to a <span>.

- The Validation Summary Tag Helper is used to display validation errors for the model, as well as for individual properties. 
  We can use model-level properties to display additional validation that doesn’t apply to just one property. 
  Use the asp-validation-summary attribute to attach the Validation Summary Tag Helper to a <div>.

- We can generate <a> URLs using the Anchor Tag Helper. 
  This helper uses routing to generate the href URL using asp-page, asp-page-handler, and asp-route-* attributes, giving us the full power of routing.

- We can add the asp-append-version attribute to <link>, <script>, and <img> elements to provide cache-busting capabilities based on the file’s contents. 
  This ensures users cache files for performance reasons, yet still always get the latest version of files.

- We can use the Environment Tag Helper to conditionally render different HTML based on the app’s current execution environment. 
  We can use this to render completely different HTML in different environments if we wish.

